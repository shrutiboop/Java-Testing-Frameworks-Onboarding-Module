*Written by Chris Fitzgerald*



### Basic Test Cases

When choosing JUnit Jupiter when using `gradle init` grants the starting file `AppTest.java` under the `\<ProjectName>\app\src\test\java\<sourcepackage>\` directory:

```
/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package newproject;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class AppTest {
    @Test void appHasAGreeting() {
        App classUnderTest = new App();
        assertNotNull(classUnderTest.getGreeting(), "app should have a greeting");
    }
}

```
The `@Test` annotation before the method signature designates the method as a test. When methods are designated as tests, they can be run on the command line with `gradle test` or alongside other build operations during `gradle build`.

As you can see, the first thing the testing method does is create an instance of the class it wishes to test. You can use the instance of the class under test to call methods and check their return values. This method checks that the return value from `classUnderTest.getGreeting()` is not null with the `assertNotNull()` method. If the first parameter is null, the `assertNotNull` will raise a test failure with the message given by the second parameter.

***

`gradle init` also generates a `build.gradle` file that specifies what needs to be done to build, run, and test your app. The following section of `build.gradle` is generated based on which testing framework was picked, so it instructs gradle to use JUnit for testing:

```
tasks.named('test') {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
}
```
***

## Writing our own tests

Now we can start writing tests for our own app. The app we will be writing tests for is a recreation of the board game _Othello_ that is run on the command line.

We can start by writing some tests for the `Board.java` class. The first function we will look at is `ReplacePiece()`
```
public void ReplacePiece (Space type, int x, int y) {
    if (x < 1 || x > BoardSize || y < 1 || y > BoardSize) { return; }
    board[x][y] = type;
}
```

This test will call `ReplacePiece()` then check to see if the piece was properly replaced:
```
    @Test
    void ReplacePieceTest() {
        Board board = new Board();

        board.ReplacePiece(Space.White, 1, 1);
        assertEquals(board.getPiece(1, 1), Space.White);
    }
```
_Note: JUnit cares about access control and cannot access private methods or attributes from other classes._

Gradle creates an HTML document based on our tests. The document can be located here: `app\build\reports\tests\test\index.html`

Now lets try testing the `PlayMove()` method multiple times with one function. Here's the `PlayMove()` method for reference:

```
public void PlayMove (Move move) {
    board[move.Position.X()][move.Position.Y()] = move.Type();

    if (move.Flips != null) {
        for (Pos pos : move.Flips) {
            Space colour = board[pos.X()][pos.Y()];
            board[pos.X()][pos.Y()] = GetReverse(colour);
        }
    }
}
``` 

We can use @ParameterizedTest to specify that our testing method can take parameters, and @MethodSource to give our testing method a stream of values to test. First lets add the required import statements:
```
import java.util.ArrayList;
import java.util.stream.Stream;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
```
Then we can add the testing method and the method that provides the testing values:
```
    @ParameterizedTest
    @MethodSource("providePerameters")
    void PlayMoveTest(int x, int y, Space space) {

        //perform a bunch of operations
        Board board = new Board();
        ArrayList<Pos> flips = new ArrayList<Pos>();
        flips.add(new Pos(4, 4));
        Move move = new Move(new Pos(4, 3), Space.Black, flips);
        board.PlayMove(move);

        //check that the operations are correct
        assertEquals(board.getPiece(x, y), space);

    }

    private static Stream<Arguments> providePerameters() {
        return Stream.of(
            Arguments.of(4, 3, Space.Black),
            Arguments.of(4, 4, Space.Black),
            Arguments.of(4, 5, Space.Black),
            Arguments.of(5, 4, Space.Black),
            Arguments.of(5, 5, Space.White)
        );
    }
```
The `providePerameters()` method provides a stream of arguments that the `PlayMoveTest()` method can use over multiple tests. Each line of `Arguments.of()` will be provided to `PlayMoveTest()` on a new run through of that method, and each time `PlayMoveTest()` is run, it sets up the board before checking that the provided parameters, match the state of the board using the `assertEquals()` method.

## Testing Multiple Things in Order

In a lot of cases you would want to have multiple tests execute in the same order every time. JUnit's `@TestMethodOrder` Annotation lets you do that very easily.

Lets create a new class to test the `Game.java` class:

```
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;
import static org.junit.jupiter.api.Assertions.*;

@TestMethodOrder(OrderAnnotation.class)
class GameTest {
    private static Game game = new Game();

    @Test
    @Order(1)
    void Setup() {
        System.out.println("Enter Setup");
        Pos pos = new Pos(3, 4);
        System.out.println("Position to be placed is " + pos.toString());
        game.PlacePiece(pos);
        System.out.println("Exit Setup");
    }

}
```

This time we need to add the `@TestMethodOrder` annotation to the class and the `@Order` annotation to each method. So far we just have the setup method, which just makes a move that places a black piece at (3, 4) which flips the piece at (4, 4) to black.

You'll notice that I am using a `System.out.println()` function in `Setup()`. This allows you to print out things that are happening and it is really useful for debugging what is wrong. It will appear in the HTML output that Gradle generates.

After setting up the tests, lets make a test to save the board to a file:
```
    @Test
    @Order(2)
    void SaveToFileTest() {
        assertTrue(game.SaveToFile("test.sav"));
    }
```
This test is very simple since we already did all the setup in the `Setup()` method.

Now lets test playing one of the possible positions:
```
@Test
    @Order(3)
    void PlayFirstPossibleMoveTest() {
        System.out.println("\nPlay a move");
        Space turn = game.CurrentTurn();
        Pos pos = game.GetPossiblePositions().get(0);

        System.out.println("Position to be placed is " + pos.toString());
        game.PlacePiece(pos);

        assertEquals(game.getBoardPiece(pos.X(), pos.Y()), turn);
        System.out.println("Exit");
    }
```
For this test we only check that the one piece was placed, not check that the move was made correctly just to keep things simple.

Next we can create a test to load the board from before we made the play:
```
    @Test
    @Order(4)
    void LoadBoardTest() {
        game.LoadBoard("test.sav");
        assertEquals(game.CurrentTurn(), Space.White);
    }
```

Then we can check that the spaces were loaded to the correct state, using what we learned with `@ParameterizedTest`:
```
    @ParameterizedTest
    @Order(5)
    @MethodSource("providePerameters")
    void LoadedBoardCorrectlyTest(int x, int y, Space space) {
        assertEquals(game.getBoardPiece(x, y), space);
    }

    private static Stream<Arguments> providePerameters() {
        return Stream.of(
            Arguments.of(3, 4, Space.Black),
            Arguments.of(4, 4, Space.Black),
            Arguments.of(5, 4, Space.Black),
            Arguments.of(4, 5, Space.Black),
            Arguments.of(5, 5, Space.White)
        );
    }
```

Remember to add the imports for the previous test:
```
import java.util.ArrayList;
import java.util.stream.Stream;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
```

And finally we can remove the save file with a `cleanup()` method:
```
    @Test
    @Order(6)
    void cleanup() {
        File file = new File("test.sav");
        boolean success = file.delete();
        if (success) {
            System.out.println("\nDeleted the save file");
        } else {
            System.out.println("\nCouldn't Delete the save file");
        }
        assertTrue(success);
    }
```

This class now tests saving and loading of games and even cleans up after itself! Don't forget to import `java.io.File;`. 

That is it for the tutorial on JUnit!